# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-21T14:13:05.714
# original file: /home/joseph/RFfusion.jl/proto/RFpacket.proto (proto3 syntax)

module RFpacket_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export PacketHeader, RFPacket


struct PacketHeader
    version::UInt32
    stream_id::UInt32
    sequence::UInt32
    timestamp_us::UInt64
    flags::UInt32
    sync_marker::Vector{UInt8}
end
PB.default_values(::Type{PacketHeader}) = (;version = zero(UInt32), stream_id = zero(UInt32), sequence = zero(UInt32), timestamp_us = zero(UInt64), flags = zero(UInt32), sync_marker = UInt8[])
PB.field_numbers(::Type{PacketHeader}) = (;version = 1, stream_id = 2, sequence = 3, timestamp_us = 4, flags = 5, sync_marker = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PacketHeader})
    version = zero(UInt32)
    stream_id = zero(UInt32)
    sequence = zero(UInt32)
    timestamp_us = zero(UInt64)
    flags = zero(UInt32)
    sync_marker = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            version = PB.decode(d, UInt32)
        elseif field_number == 2
            stream_id = PB.decode(d, UInt32)
        elseif field_number == 3
            sequence = PB.decode(d, UInt32)
        elseif field_number == 4
            timestamp_us = PB.decode(d, UInt64)
        elseif field_number == 5
            flags = PB.decode(d, UInt32)
        elseif field_number == 6
            sync_marker = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return PacketHeader(version, stream_id, sequence, timestamp_us, flags, sync_marker)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PacketHeader)
    initpos = position(e.io)
    x.version != zero(UInt32) && PB.encode(e, 1, x.version)
    x.stream_id != zero(UInt32) && PB.encode(e, 2, x.stream_id)
    x.sequence != zero(UInt32) && PB.encode(e, 3, x.sequence)
    x.timestamp_us != zero(UInt64) && PB.encode(e, 4, x.timestamp_us)
    x.flags != zero(UInt32) && PB.encode(e, 5, x.flags)
    !isempty(x.sync_marker) && PB.encode(e, 6, x.sync_marker)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PacketHeader)
    encoded_size = 0
    x.version != zero(UInt32) && (encoded_size += PB._encoded_size(x.version, 1))
    x.stream_id != zero(UInt32) && (encoded_size += PB._encoded_size(x.stream_id, 2))
    x.sequence != zero(UInt32) && (encoded_size += PB._encoded_size(x.sequence, 3))
    x.timestamp_us != zero(UInt64) && (encoded_size += PB._encoded_size(x.timestamp_us, 4))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 5))
    !isempty(x.sync_marker) && (encoded_size += PB._encoded_size(x.sync_marker, 6))
    return encoded_size
end

struct RFPacket
    header::Union{Nothing,PacketHeader}
    node_label::String
    status_msg::String
    rf_packet::Vector{UInt8}
    firmware_update::Vector{UInt8}
    spectrum_bytes::Vector{UInt8}
end
PB.default_values(::Type{RFPacket}) = (;header = nothing, node_label = "", status_msg = "", rf_packet = UInt8[], firmware_update = UInt8[], spectrum_bytes = UInt8[])
PB.field_numbers(::Type{RFPacket}) = (;header = 1, node_label = 2, status_msg = 3, rf_packet = 4, firmware_update = 5, spectrum_bytes = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RFPacket})
    header = Ref{Union{Nothing,PacketHeader}}(nothing)
    node_label = ""
    status_msg = ""
    rf_packet = UInt8[]
    firmware_update = UInt8[]
    spectrum_bytes = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, header)
        elseif field_number == 2
            node_label = PB.decode(d, String)
        elseif field_number == 3
            status_msg = PB.decode(d, String)
        elseif field_number == 4
            rf_packet = PB.decode(d, Vector{UInt8})
        elseif field_number == 5
            firmware_update = PB.decode(d, Vector{UInt8})
        elseif field_number == 6
            spectrum_bytes = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return RFPacket(header[], node_label, status_msg, rf_packet, firmware_update, spectrum_bytes)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RFPacket)
    initpos = position(e.io)
    !isnothing(x.header) && PB.encode(e, 1, x.header)
    !isempty(x.node_label) && PB.encode(e, 2, x.node_label)
    !isempty(x.status_msg) && PB.encode(e, 3, x.status_msg)
    !isempty(x.rf_packet) && PB.encode(e, 4, x.rf_packet)
    !isempty(x.firmware_update) && PB.encode(e, 5, x.firmware_update)
    !isempty(x.spectrum_bytes) && PB.encode(e, 6, x.spectrum_bytes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RFPacket)
    encoded_size = 0
    !isnothing(x.header) && (encoded_size += PB._encoded_size(x.header, 1))
    !isempty(x.node_label) && (encoded_size += PB._encoded_size(x.node_label, 2))
    !isempty(x.status_msg) && (encoded_size += PB._encoded_size(x.status_msg, 3))
    !isempty(x.rf_packet) && (encoded_size += PB._encoded_size(x.rf_packet, 4))
    !isempty(x.firmware_update) && (encoded_size += PB._encoded_size(x.firmware_update, 5))
    !isempty(x.spectrum_bytes) && (encoded_size += PB._encoded_size(x.spectrum_bytes, 6))
    return encoded_size
end
end # module
