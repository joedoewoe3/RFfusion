# Autogenerated using ProtoBuf.jl v1.2.0 on 2025-12-20T14:19:02.444
# original file: C:\Users\joedo\forgotmyfirstAIloveusb\RFpacket.proto (proto3 syntax)

module RFpacket_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Control, FilteredState, PacketHeader, AntennaData, PayloadKind, Residual, Prediction
export RawSample, SignalPacket


struct Control
    kind::String
    new_version::UInt32
    payload::Vector{UInt8}
end
PB.default_values(::Type{Control}) = (;kind = "", new_version = zero(UInt32), payload = UInt8[])
PB.field_numbers(::Type{Control}) = (;kind = 1, new_version = 2, payload = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Control})
    kind = ""
    new_version = zero(UInt32)
    payload = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            kind = PB.decode(d, String)
        elseif field_number == 2
            new_version = PB.decode(d, UInt32)
        elseif field_number == 3
            payload = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return Control(kind, new_version, payload)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Control)
    initpos = position(e.io)
    !isempty(x.kind) && PB.encode(e, 1, x.kind)
    x.new_version != zero(UInt32) && PB.encode(e, 2, x.new_version)
    !isempty(x.payload) && PB.encode(e, 3, x.payload)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Control)
    encoded_size = 0
    !isempty(x.kind) && (encoded_size += PB._encoded_size(x.kind, 1))
    x.new_version != zero(UInt32) && (encoded_size += PB._encoded_size(x.new_version, 2))
    !isempty(x.payload) && (encoded_size += PB._encoded_size(x.payload, 3))
    return encoded_size
end

struct FilteredState
    x::Vector{Float32}
    P_flat::Vector{Float32}
    model_version::UInt32
    param_hash::Vector{UInt8}
end
PB.default_values(::Type{FilteredState}) = (;x = Vector{Float32}(), P_flat = Vector{Float32}(), model_version = zero(UInt32), param_hash = UInt8[])
PB.field_numbers(::Type{FilteredState}) = (;x = 1, P_flat = 2, model_version = 3, param_hash = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FilteredState})
    x = PB.BufferedVector{Float32}()
    P_flat = PB.BufferedVector{Float32}()
    model_version = zero(UInt32)
    param_hash = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, x)
        elseif field_number == 2
            PB.decode!(d, wire_type, P_flat)
        elseif field_number == 3
            model_version = PB.decode(d, UInt32)
        elseif field_number == 4
            param_hash = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return FilteredState(x[], P_flat[], model_version, param_hash)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FilteredState)
    initpos = position(e.io)
    !isempty(x.x) && PB.encode(e, 1, x.x)
    !isempty(x.P_flat) && PB.encode(e, 2, x.P_flat)
    x.model_version != zero(UInt32) && PB.encode(e, 3, x.model_version)
    !isempty(x.param_hash) && PB.encode(e, 4, x.param_hash)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FilteredState)
    encoded_size = 0
    !isempty(x.x) && (encoded_size += PB._encoded_size(x.x, 1))
    !isempty(x.P_flat) && (encoded_size += PB._encoded_size(x.P_flat, 2))
    x.model_version != zero(UInt32) && (encoded_size += PB._encoded_size(x.model_version, 3))
    !isempty(x.param_hash) && (encoded_size += PB._encoded_size(x.param_hash, 4))
    return encoded_size
end

struct PacketHeader
    version::UInt32
    stream_id::UInt32
    sequence::UInt32
    timestamp_us::UInt64
    flags::UInt32
    sync_marker::Vector{UInt8}
end
PB.default_values(::Type{PacketHeader}) = (;version = zero(UInt32), stream_id = zero(UInt32), sequence = zero(UInt32), timestamp_us = zero(UInt64), flags = zero(UInt32), sync_marker = UInt8[])
PB.field_numbers(::Type{PacketHeader}) = (;version = 1, stream_id = 2, sequence = 3, timestamp_us = 4, flags = 5, sync_marker = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PacketHeader})
    version = zero(UInt32)
    stream_id = zero(UInt32)
    sequence = zero(UInt32)
    timestamp_us = zero(UInt64)
    flags = zero(UInt32)
    sync_marker = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            version = PB.decode(d, UInt32)
        elseif field_number == 2
            stream_id = PB.decode(d, UInt32)
        elseif field_number == 3
            sequence = PB.decode(d, UInt32)
        elseif field_number == 4
            timestamp_us = PB.decode(d, UInt64)
        elseif field_number == 5
            flags = PB.decode(d, UInt32)
        elseif field_number == 6
            sync_marker = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return PacketHeader(version, stream_id, sequence, timestamp_us, flags, sync_marker)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PacketHeader)
    initpos = position(e.io)
    x.version != zero(UInt32) && PB.encode(e, 1, x.version)
    x.stream_id != zero(UInt32) && PB.encode(e, 2, x.stream_id)
    x.sequence != zero(UInt32) && PB.encode(e, 3, x.sequence)
    x.timestamp_us != zero(UInt64) && PB.encode(e, 4, x.timestamp_us)
    x.flags != zero(UInt32) && PB.encode(e, 5, x.flags)
    !isempty(x.sync_marker) && PB.encode(e, 6, x.sync_marker)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PacketHeader)
    encoded_size = 0
    x.version != zero(UInt32) && (encoded_size += PB._encoded_size(x.version, 1))
    x.stream_id != zero(UInt32) && (encoded_size += PB._encoded_size(x.stream_id, 2))
    x.sequence != zero(UInt32) && (encoded_size += PB._encoded_size(x.sequence, 3))
    x.timestamp_us != zero(UInt64) && (encoded_size += PB._encoded_size(x.timestamp_us, 4))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 5))
    !isempty(x.sync_marker) && (encoded_size += PB._encoded_size(x.sync_marker, 6))
    return encoded_size
end

struct AntennaData
    name::String
    rss::Float64
    tdoa::Vector{Float64}
    aoa::Vector{Float64}
    units::String
end
PB.default_values(::Type{AntennaData}) = (;name = "", rss = zero(Float64), tdoa = Vector{Float64}(), aoa = Vector{Float64}(), units = "")
PB.field_numbers(::Type{AntennaData}) = (;name = 1, rss = 2, tdoa = 3, aoa = 4, units = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AntennaData})
    name = ""
    rss = zero(Float64)
    tdoa = PB.BufferedVector{Float64}()
    aoa = PB.BufferedVector{Float64}()
    units = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            rss = PB.decode(d, Float64)
        elseif field_number == 3
            PB.decode!(d, wire_type, tdoa)
        elseif field_number == 4
            PB.decode!(d, wire_type, aoa)
        elseif field_number == 5
            units = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return AntennaData(name, rss, tdoa[], aoa[], units)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AntennaData)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.rss !== zero(Float64) && PB.encode(e, 2, x.rss)
    !isempty(x.tdoa) && PB.encode(e, 3, x.tdoa)
    !isempty(x.aoa) && PB.encode(e, 4, x.aoa)
    !isempty(x.units) && PB.encode(e, 5, x.units)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AntennaData)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.rss !== zero(Float64) && (encoded_size += PB._encoded_size(x.rss, 2))
    !isempty(x.tdoa) && (encoded_size += PB._encoded_size(x.tdoa, 3))
    !isempty(x.aoa) && (encoded_size += PB._encoded_size(x.aoa, 4))
    !isempty(x.units) && (encoded_size += PB._encoded_size(x.units, 5))
    return encoded_size
end

@enumx PayloadKind RAW=0 FILTERED=1 PREDICTION=2 RESIDUAL=3 CONTROL=4

struct Residual
    innovation::Vector{Float32}
    mae::Float32
    rmse::Float32
end
PB.default_values(::Type{Residual}) = (;innovation = Vector{Float32}(), mae = zero(Float32), rmse = zero(Float32))
PB.field_numbers(::Type{Residual}) = (;innovation = 1, mae = 2, rmse = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Residual})
    innovation = PB.BufferedVector{Float32}()
    mae = zero(Float32)
    rmse = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, innovation)
        elseif field_number == 2
            mae = PB.decode(d, Float32)
        elseif field_number == 3
            rmse = PB.decode(d, Float32)
        else
            Base.skip(d, wire_type)
        end
    end
    return Residual(innovation[], mae, rmse)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Residual)
    initpos = position(e.io)
    !isempty(x.innovation) && PB.encode(e, 1, x.innovation)
    x.mae !== zero(Float32) && PB.encode(e, 2, x.mae)
    x.rmse !== zero(Float32) && PB.encode(e, 3, x.rmse)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Residual)
    encoded_size = 0
    !isempty(x.innovation) && (encoded_size += PB._encoded_size(x.innovation, 1))
    x.mae !== zero(Float32) && (encoded_size += PB._encoded_size(x.mae, 2))
    x.rmse !== zero(Float32) && (encoded_size += PB._encoded_size(x.rmse, 3))
    return encoded_size
end

struct Prediction
    y_hat::Vector{Float32}
    horizon_steps::UInt32
    step_interval_ms::Float32
    conf_lower::Vector{Float32}
    conf_upper::Vector{Float32}
    model_version::UInt32
end
PB.default_values(::Type{Prediction}) = (;y_hat = Vector{Float32}(), horizon_steps = zero(UInt32), step_interval_ms = zero(Float32), conf_lower = Vector{Float32}(), conf_upper = Vector{Float32}(), model_version = zero(UInt32))
PB.field_numbers(::Type{Prediction}) = (;y_hat = 1, horizon_steps = 2, step_interval_ms = 3, conf_lower = 4, conf_upper = 5, model_version = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Prediction})
    y_hat = PB.BufferedVector{Float32}()
    horizon_steps = zero(UInt32)
    step_interval_ms = zero(Float32)
    conf_lower = PB.BufferedVector{Float32}()
    conf_upper = PB.BufferedVector{Float32}()
    model_version = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, y_hat)
        elseif field_number == 2
            horizon_steps = PB.decode(d, UInt32)
        elseif field_number == 3
            step_interval_ms = PB.decode(d, Float32)
        elseif field_number == 4
            PB.decode!(d, wire_type, conf_lower)
        elseif field_number == 5
            PB.decode!(d, wire_type, conf_upper)
        elseif field_number == 6
            model_version = PB.decode(d, UInt32)
        else
            Base.skip(d, wire_type)
        end
    end
    return Prediction(y_hat[], horizon_steps, step_interval_ms, conf_lower[], conf_upper[], model_version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Prediction)
    initpos = position(e.io)
    !isempty(x.y_hat) && PB.encode(e, 1, x.y_hat)
    x.horizon_steps != zero(UInt32) && PB.encode(e, 2, x.horizon_steps)
    x.step_interval_ms !== zero(Float32) && PB.encode(e, 3, x.step_interval_ms)
    !isempty(x.conf_lower) && PB.encode(e, 4, x.conf_lower)
    !isempty(x.conf_upper) && PB.encode(e, 5, x.conf_upper)
    x.model_version != zero(UInt32) && PB.encode(e, 6, x.model_version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Prediction)
    encoded_size = 0
    !isempty(x.y_hat) && (encoded_size += PB._encoded_size(x.y_hat, 1))
    x.horizon_steps != zero(UInt32) && (encoded_size += PB._encoded_size(x.horizon_steps, 2))
    x.step_interval_ms !== zero(Float32) && (encoded_size += PB._encoded_size(x.step_interval_ms, 3))
    !isempty(x.conf_lower) && (encoded_size += PB._encoded_size(x.conf_lower, 4))
    !isempty(x.conf_upper) && (encoded_size += PB._encoded_size(x.conf_upper, 5))
    x.model_version != zero(UInt32) && (encoded_size += PB._encoded_size(x.model_version, 6))
    return encoded_size
end

struct RawSample
    antennas::Vector{AntennaData}
end
PB.default_values(::Type{RawSample}) = (;antennas = Vector{AntennaData}())
PB.field_numbers(::Type{RawSample}) = (;antennas = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RawSample})
    antennas = PB.BufferedVector{AntennaData}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, antennas)
        else
            Base.skip(d, wire_type)
        end
    end
    return RawSample(antennas[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RawSample)
    initpos = position(e.io)
    !isempty(x.antennas) && PB.encode(e, 1, x.antennas)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RawSample)
    encoded_size = 0
    !isempty(x.antennas) && (encoded_size += PB._encoded_size(x.antennas, 1))
    return encoded_size
end

struct SignalPacket
    header::Union{Nothing,PacketHeader}
    kind::PayloadKind.T
    payload::Union{Nothing,OneOf{<:Union{RawSample,FilteredState,Prediction,Residual,Control}}}
    crc32::UInt32
end
PB.oneof_field_types(::Type{SignalPacket}) = (;
    payload = (;raw=RawSample, filtered=FilteredState, predict=Prediction, residual=Residual, control=Control),
)
PB.default_values(::Type{SignalPacket}) = (;header = nothing, kind = PayloadKind.RAW, raw = nothing, filtered = nothing, predict = nothing, residual = nothing, control = nothing, crc32 = zero(UInt32))
PB.field_numbers(::Type{SignalPacket}) = (;header = 1, kind = 2, raw = 3, filtered = 4, predict = 5, residual = 6, control = 7, crc32 = 15)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SignalPacket})
    header = Ref{Union{Nothing,PacketHeader}}(nothing)
    kind = PayloadKind.RAW
    payload = nothing
    crc32 = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, header)
        elseif field_number == 2
            kind = PB.decode(d, PayloadKind.T)
        elseif field_number == 3
            payload = OneOf(:raw, PB.decode(d, Ref{RawSample}))
        elseif field_number == 4
            payload = OneOf(:filtered, PB.decode(d, Ref{FilteredState}))
        elseif field_number == 5
            payload = OneOf(:predict, PB.decode(d, Ref{Prediction}))
        elseif field_number == 6
            payload = OneOf(:residual, PB.decode(d, Ref{Residual}))
        elseif field_number == 7
            payload = OneOf(:control, PB.decode(d, Ref{Control}))
        elseif field_number == 15
            crc32 = PB.decode(d, UInt32)
        else
            Base.skip(d, wire_type)
        end
    end
    return SignalPacket(header[], kind, payload, crc32)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SignalPacket)
    initpos = position(e.io)
    !isnothing(x.header) && PB.encode(e, 1, x.header)
    x.kind != PayloadKind.RAW && PB.encode(e, 2, x.kind)
    if isnothing(x.payload);
    elseif x.payload.name === :raw
        PB.encode(e, 3, x.payload[]::RawSample)
    elseif x.payload.name === :filtered
        PB.encode(e, 4, x.payload[]::FilteredState)
    elseif x.payload.name === :predict
        PB.encode(e, 5, x.payload[]::Prediction)
    elseif x.payload.name === :residual
        PB.encode(e, 6, x.payload[]::Residual)
    elseif x.payload.name === :control
        PB.encode(e, 7, x.payload[]::Control)
    end
    x.crc32 != zero(UInt32) && PB.encode(e, 15, x.crc32)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SignalPacket)
    encoded_size = 0
    !isnothing(x.header) && (encoded_size += PB._encoded_size(x.header, 1))
    x.kind != PayloadKind.RAW && (encoded_size += PB._encoded_size(x.kind, 2))
    if isnothing(x.payload);
    elseif x.payload.name === :raw
        encoded_size += PB._encoded_size(x.payload[]::RawSample, 3)
    elseif x.payload.name === :filtered
        encoded_size += PB._encoded_size(x.payload[]::FilteredState, 4)
    elseif x.payload.name === :predict
        encoded_size += PB._encoded_size(x.payload[]::Prediction, 5)
    elseif x.payload.name === :residual
        encoded_size += PB._encoded_size(x.payload[]::Residual, 6)
    elseif x.payload.name === :control
        encoded_size += PB._encoded_size(x.payload[]::Control, 7)
    end
    x.crc32 != zero(UInt32) && (encoded_size += PB._encoded_size(x.crc32, 15))
    return encoded_size
end
end # module
